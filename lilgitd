#!/usr/bin/env python3
import sys
import os
import signal
import fcntl
import threading
import subprocess

import pygit2


def desc(repo, detached, name):
    if detached:
        return "detached @ {:.11}".format(str(name))
    else:
        return name


def dirty(repo, detached, head, name):
    if (
        not detached
        and repo.branches[name].upstream
        and head.target != repo.branches[name].upstream.target
    ):
        return True  # ahead or behind

    # for some reason shelling out beats the socks off of repo.diff perf
    y = subprocess.run(["git", "diff", "--quiet", "@{u}"], capture_output=True)
    if y.returncode == 128:
        y = subprocess.run(["git", "diff", "--quiet", "HEAD"], capture_output=True)

    if y.returncode > 0:
        return True
    else:
        return False


def report(start_path):
    try:
        path = pygit2.discover_repository(start_path)
        repo = pygit2.Repository(path)
        detached = repo.head_is_detached
        head = repo.head
        name = head.target if detached else head.shorthand
    except pygit2.GitError as e:
        return (False, False, "")

    return (
        True,
        dirty(repo, detached, head, name),
        desc(repo, detached, name),
    )


def main():
    paths = sys.argv[1:]
    if len(paths) == 1:
        print(*report(paths[0]), flush=True)
    elif len(paths) > 1:
        for path in paths:
            print(*path, *report(path), flush=True)


if len(sys.argv) > 1:
    main()
else:
    # begin something borrowed:
    # https://stackoverflow.com/a/26640086/307542
    io_event = threading.Event()

    # Event handlers should generally be as compact as possible.
    # Here all we do is notify the main thread that input has been received.
    def handle_io(signal, frame):
        io_event.set()

    # invoke handle_io on a SIGIO event
    signal.signal(signal.SIGIO, handle_io)
    # try not dying on ctrl-c
    signal.signal(signal.SIGINT, signal.SIG_IGN)
    # send io events on stdin (fd 0) to our process
    assert fcntl.fcntl(0, fcntl.F_SETOWN, os.getpid()) == 0
    # tell the os to produce SIGIO events when data is written to stdin
    assert fcntl.fcntl(0, fcntl.F_SETFL, os.O_ASYNC) == 0
    while True:
        from_shell = sys.stdin.readline()
        io_event.clear()
        # end something borrowed
        try:
            print(*report(from_shell.splitlines()[0]), flush=True)
        except IndexError as e:
            sys.exit(0)
        io_event.wait()  # I lied; also borrowed
